# Gemma 3 Interleaved Sliding Window Attention

This report documents how the Ollama codebase implements **interleaved sliding window attention** for Gemma 3 models.

## Model Initialization
- Gemma 3 models create a `WrapperCache` composed of a sliding‑window cache (`NewSWACache`) and a full causal cache (`NewCausalCache`). The sliding window size comes from the model configuration (`attention.sliding_window`).
- `model/models/gemma3/model.go` shows this setup:

```go
slidingWindowLen := int32(c.Uint("attention.sliding_window"))
m.Cache = kvcache.NewWrapperCache(kvcache.NewSWACache(slidingWindowLen, m.Shift), kvcache.NewCausalCache(m.Shift))
```
【F:model/models/gemma3/model.go†L83-L86】

## Per‑Layer Cache Selection
- `TextModel.Forward` iterates over layers and alternates between the two caches every six layers (constant `gemmaGlobalCacheCount`).
- When the layer index modulo 6 equals zero, the global (causal) cache is used; otherwise the sliding window cache is selected.
- Relevant code in `model/models/gemma3/model_text.go`:

```go
// gemma alternates between the sliding window (local) and causal (global)
// kv cache every 6 layers
cacheType := cacheTypeSWA
if (i+1)%gemmaGlobalCacheCount == 0 {
    cacheType = cacheTypeCausal
}
cache.SetLayer(i)
wc := cache.(*kvcache.WrapperCache)
wc.SetLayerType(cacheType)
```
【F:model/models/gemma3/model_text.go†L177-L186】

## Shifting Cached Keys
- Sliding window eviction requires shifting cached keys so that rotary embeddings stay aligned.
- The `Shift` method in `TextModel` performs this rotation using `fast.RoPE` with either the local or global RoPE base depending on the layer:

```go
func (m *TextModel) Shift(ctx ml.Context, layer int, key, shift ml.Tensor) (ml.Tensor, error) {
    ropeBase := m.TextConfig.ropeLocalBase
    if (layer+1)%gemmaGlobalCacheCount == 0 {
        ropeBase = m.TextConfig.ropeGlobalBase
    }
    return fast.RoPE(ctx, key, shift, m.TextConfig.attnKeyLen, ropeBase, m.TextConfig.ropeScale, rope.WithTypeNeoX()), nil
}
```
【F:model/models/gemma3/model_text.go†L110-L116】

## Sliding Window Cache Implementation
- `NewSWACache` creates a `Causal` cache with a finite `windowSize`:

```go
func NewSWACache(windowSize int32, shift shiftFn) *Causal {
    return &Causal{
        windowSize: windowSize,
        shiftFn:    shift,
        ctxs:       make(map[int]ml.Context),
        keys:       make(map[int]ml.Tensor),
        values:     make(map[int]ml.Tensor),
    }
}
```
【F:kvcache/causal.go†L96-L103】

- During each forward pass `updateSlidingWindow` removes entries older than the configured window for each sequence:

```go
func (c *Causal) updateSlidingWindow() {
    if c.windowSize == math.MaxInt32 {
        return
    }
    // create a map of unique sequences to the lowest position in that sequence
    lowestPos := make(map[int]int32)
    ...
    for seq, pos := range lowestPos {
        oldRange, ok := c.cellRanges[seq]
        if !ok {
            continue
        }
        newRange := newRange()
        for i := oldRange.min; i <= oldRange.max; i++ {
            if slices.Contains(c.cells[i].sequences, seq) {
                if c.cells[i].pos < pos-c.windowSize {
                    c.cells[i].sequences = slices.DeleteFunc(c.cells[i].sequences, func(s int) bool { return s == seq })
                } else {
                    newRange.min = min(newRange.min, i)
                    newRange.max = max(newRange.max, i)
                }
            }
        }
        c.cellRanges[seq] = newRange
    }
}
```
【F:kvcache/causal.go†L250-L291】

## Cache Memory Allocation
- When the GGML loader allocates cache memory, Gemma 3 adjusts the amount for sliding window layers so that non‑global layers allocate only `sliding_window` entries plus batch size:

```go
// Gemma2 also has sliding window attention but we only have an optimized implementation in the Ollama
// engine. Gemma3 always uses the Ollama engine.
if f.KV().Architecture() == "gemma3" {
    const gemma3GlobalCacheCount = 6
    slidingWindow := (uint64(numParallel) * uint64(f.KV().Uint("attention.sliding_window"))) + batch
    for i := range kv {
        // Every 6th layer is a global layer, which is the full context size that has already been set. The other
        // layers are the smaller local (sliding) layers.
        if (i+1)%gemma3GlobalCacheCount != 0 {
            kv[i] = uint64(float64(slidingWindow*(embeddingHeadsK+embeddingHeadsV)*headsKV) * bytesPerElement)
        }
    }
}
```
【F:fs/ggml/ggml.go†L558-L587】

## Wrapper Cache
- `WrapperCache` selects which underlying cache (sliding or causal) to use for a layer. `SetLayerType` switches the active cache:

```go
func (c *WrapperCache) SetLayerType(layerType int) {
    c.curType = layerType
}

func (c *WrapperCache) UnderlyingCache() Cache {
    return c.caches[c.curType]
}
```
【F:kvcache/wrapper.go†L68-L74】

## Summary
Gemma 3 models use a pair of caches—one with a limited sliding window and one with full causal history. `TextModel.Forward` alternates between them every six layers. When a sliding window layer is active, the `Causal` cache enforces the window by dropping old entries in `updateSlidingWindow`, and the model's `Shift` function rotates cached keys so the RoPE embeddings stay consistent. Memory allocations are adjusted to account for the smaller local layers. This pattern of alternating cache types implements **interleaved sliding window attention** across the transformer layers.
